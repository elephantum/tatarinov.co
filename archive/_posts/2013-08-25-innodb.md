---
layout: post
title: Test post
published: false
---

# Индексы в InnoDB и противоречащая нагрузка

## Вводная

Сайт Энтера как и любого ритейлера это в первую очередь каталог.

Так как в Энтер большое количество регионов и сложная логика определения доступности, то мы поддерживаем таблицу product_zone_state, где для каждой пары <product_id, zone_id> хранится набор флагов.

Запросы к этой таблице есть двух видов:

* Первый вид запросов нужен для формирования страниц сайта/терминала. При работе на сайте клиент в явном виде задает zone_id и вся информация фильтруется по нему:
  * дай мне список товаров, удовлетворяющих таким-то параметрам в такой-то zone_id;
  * посчитай количество доступных товаров в такой-то категории и такой-то zone_id.
* Второй вид запросов нужен для индексации товаров в поисковом движке, выгрузки во внешние системы etc, везде где 
  нужно дать полную информацию по одному товару:
  * дай мне все значения флагов для такого-то product_id по всем зонам.

Таблица выросла в три раза за прошлый год. 

С течением времени наблюдалось замедление основных сервисов и приходилось горизонтально масштабироваться сильнее, 
чем предполагалось ранее.

Триггером к детальному анализу ситуации стало существенное возрастание пиковой нагрузки во время регулярных 
обновлений индекса. *Здесь картинка с пиками нагрузки на ядро.*

Эти пики транслировались в увеличившееся время ответа сайта. *Здесь картинка по ответам сайта.*

Как оказалось по результатам исследования, два вида запросов противоречат друг-другу с точки зрения кеша, дискового хранения etc, и именно об этом статья. 

## product_zone_state

Таблица product_zone_state весит 15Gb на текущий момент.

*Здесь оригинальный create table с индексом по автоинкрементномy id.*

В сущности это двумерная таблица &lt;product_id,zone_id> → &lt;state1,state2,state3>

Запросы по zone_id, фильтруют всю таблицу по zone_id=z1 и накладывают некоторые дополнительные условия. Данные которые используются при каждом таком запросе:

Запросы по product_id наоборот, ограничивают данные по product_id=p1 и как правило вычитывают все значения всех флагов:

В реальности же на диске, при использовании автоинкрементного ключа, данные на диске лежат в разнобой и каждый чанк содержит в себе значения как из разных зон, так и разных товаров:

## Оптимизации

## Результат
